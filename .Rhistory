library(wrappify)
install.packages("tidyverse")
library(wrappify)
?is
is('f')
is('f', 'character')
?httr
import::from(httr, POST)
import::from(httr, POST)
install.packages("import")
import::from(httr, POST)
import::from(httr, POST)
?glue
??glue
library(wrappify)
library(wrappify)
?import
install.packages("import")
#library(jsonlite)
#library(httr)
#library(glue)
#library(stringr)
#library(tidyverse)
#library(roxygen2)
#library(devtools)
search()
library(wrappify)
library(wrappify)
rcmdcheck::rcmdcheck()
#' expired tokens are refreshed when needed automatically
#'
#' @param CLIENT_ID A Spotify client ID which the user needs to acquire prior to using the package.
#' @param CLIENT_SECRET A Spotify client secret key which the user needs to acquire prior to using the package.
#'
#' @return auth_token
#' @export
#'
#' @examples
#' get_authentication_token(CLIENT_ID, CLIENT_SECRET)
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(client_id) == FALSE | is.character(client_secret_id) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = POST('https://accounts.spotify.com/api/token',
accept_json(),
authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
verbose())
if(response$status_code != 200){
stop(paste(response$status_code,":", content(response)$error$message))
}
content <- content(response)
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
context('Checking functionality of getAuthenticationToken, getArtistID, getTrackID, getTrackRecommendations')
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns an string", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa"), "character"))
})
test_that('Artist ID converter can handle missing track arguments', {
expect_true(is(getArtistID(authentication_token = NULL), 'NULL'))
expect_message(getArtistID(authentication_token = NULL), 'No artist string provided.')
})
rm(list = c("getArtistID", "getAuthenticationToken", "getTrackID"))
?load_all
??load_all
library(wrappify)
library(wrappify)
library(wrappify)
getArtistID('')
getAuthenticationToken()
library(wrappify)
getAuthenticationToken()
?do.call
library(wrappify)
getAuthenticationToken()
getArtistID('')
library(wrappify)
content <- httr::content(response)
content <- httr::content(response)
source('~/OneDrive - The University Of British Columbia/data_534 - Web + Cloud Computing/DATA534_Project_G2/R/getAuthenticationToken.R', echo=TRUE)
library(wrappify)
?subset
library(wrappify)
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
if(response$status_code != 200){
message(paste(response$status_code,":", content$error$message))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
test_that('A test to check if an error is raised on entering an invalid client or secret ID', {
expect_error(getAuthenticationToken('abcd',1))
expect_error(getAuthenticationToken('abcd','abcd'))
})
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
return(content)
if(response$status_code != 200){
message(paste(response$status_code,":", content$error$message))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
c <- getAuthenticationToken()
c
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
return(list(content, response))
if(response$status_code != 200){
message(paste(response$status_code,":", content$error$message))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
c <- getAuthenticationToken()
c
c <- getAuthenticationToken('undefgine', 'awda')
c
c[1]
c[1]$error
c[1]$error$message
c[2]$error$message
c[2]
c
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
if(response$status_code != 200){
message(paste(response$status_code,":", content$error_description))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
c <- getAuthenticationToken('undefgine', 'awda')
c
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
if(response$status_code != 200){
message(paste('Status code :', response$status_code))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
test_that('A test to check if an error is raised on entering an invalid client or secret ID', {
expect_error(getAuthenticationToken('abcd',1))
expect_error(getAuthenticationToken('abcd','abcd'))
})
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
if(response$status_code != 200){
stop(paste('Status code :', response$status_code))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
test_that('A test to check if an error is raised on entering an invalid client or secret ID', {
expect_error(getAuthenticationToken('abcd',1))
expect_error(getAuthenticationToken('abcd','abcd'))
})
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
stop(paste('Status code :', response$status_code))
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
test_that('A test to check if an error is raised on entering an invalid client or secret ID', {
expect_error(getAuthenticationToken('abcd',1))
expect_error(getAuthenticationToken('abcd','abcd'))
})
c <- getAuthenticationToken('undefgine', 'awda')
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message(paste('Status code :', response$status_code))
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
test_that('A test to check if an error is raised on entering an invalid client or secret ID', {
expect_error(getAuthenticationToken('abcd',1))
expect_error(getAuthenticationToken('abcd','abcd'))
})
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
library(wrappify)
library(wrappify)
