## Get response using user defined Client ID and Client Secret
response = POST('https://accounts.spotify.com/api/token',
accept_json(),
authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
verbose())
if(response$status_code != 200){
stop(paste(response$status_code,":", content(response)$error$message))
}
content <- content(response)
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
context('Checking functionality of getAuthenticationToken, getArtistID, getTrackID, getTrackRecommendations')
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns an string", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa"), "character"))
})
test_that('Artist ID converter can handle missing track arguments', {
expect_true(is(getArtistID(authentication_token = NULL), 'NULL'))
expect_message(getArtistID(authentication_token = NULL), 'No artist string provided.')
})
rm(list = c("getArtistID", "getAuthenticationToken", "getTrackID"))
?load_all
??load_all
library(wrappify)
library(wrappify)
library(wrappify)
getArtistID('')
getAuthenticationToken()
library(wrappify)
getAuthenticationToken()
?do.call
library(wrappify)
getAuthenticationToken()
getArtistID('')
library(wrappify)
content <- httr::content(response)
content <- httr::content(response)
source('~/OneDrive - The University Of British Columbia/data_534 - Web + Cloud Computing/DATA534_Project_G2/R/getAuthenticationToken.R', echo=TRUE)
library(wrappify)
?subset
library(wrappify)
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
if(response$status_code != 200){
message(paste(response$status_code,":", content$error$message))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
test_that('A test to check if an error is raised on entering an invalid client or secret ID', {
expect_error(getAuthenticationToken('abcd',1))
expect_error(getAuthenticationToken('abcd','abcd'))
})
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
return(content)
if(response$status_code != 200){
message(paste(response$status_code,":", content$error$message))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
c <- getAuthenticationToken()
c
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
return(list(content, response))
if(response$status_code != 200){
message(paste(response$status_code,":", content$error$message))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
c <- getAuthenticationToken()
c
c <- getAuthenticationToken('undefgine', 'awda')
c
c[1]
c[1]$error
c[1]$error$message
c[2]$error$message
c[2]
c
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
if(response$status_code != 200){
message(paste(response$status_code,":", content$error_description))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
c <- getAuthenticationToken('undefgine', 'awda')
c
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
if(response$status_code != 200){
message(paste('Status code :', response$status_code))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
test_that('A test to check if an error is raised on entering an invalid client or secret ID', {
expect_error(getAuthenticationToken('abcd',1))
expect_error(getAuthenticationToken('abcd','abcd'))
})
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
if(response$status_code != 200){
stop(paste('Status code :', response$status_code))
}
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
test_that('A test to check if an error is raised on entering an invalid client or secret ID', {
expect_error(getAuthenticationToken('abcd',1))
expect_error(getAuthenticationToken('abcd','abcd'))
})
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
stop(paste('Status code :', response$status_code))
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
test_that('A test to check if an error is raised on entering an invalid client or secret ID', {
expect_error(getAuthenticationToken('abcd',1))
expect_error(getAuthenticationToken('abcd','abcd'))
})
c <- getAuthenticationToken('undefgine', 'awda')
getAuthenticationToken <- function (CLIENT_ID = "7870a259411b4c8b8d2ad173b5a7ed73",
CLIENT_SECRET = "67ab42b91f224c3682ff8d5b2220f6aa") {
if (is.character(CLIENT_ID) == FALSE | is.character(CLIENT_SECRET) == FALSE){
stop('Client ID/Client Secret ID must be a string value')
}
## Get response using user defined Client ID and Client Secret
response = httr::POST('https://accounts.spotify.com/api/token',
httr::accept_json(),
httr::authenticate(CLIENT_ID, CLIENT_SECRET),
body = list(grant_type = 'client_credentials'),
encode = 'form',
httr::verbose())
content <- httr::content(response)
## If request was successful, assign a global authorization token.
## The user only needs to rerun the function to refresh their authorization token.
if (is.null(content$access_token)) {
message(paste('Status code :', response$status_code))
message('Token authentication unsuccessful. Check credentials and try again')
message('Error description: ', content$error_description)
return(NULL)
} else {
auth_token <<- content$access_token
return(auth_token)
}
}
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
test_that('A test to check if an error is raised on entering an invalid client or secret ID', {
expect_error(getAuthenticationToken('abcd',1))
expect_error(getAuthenticationToken('abcd','abcd'))
})
library(testthat)
test_that("Authorization function returns NULL and warns user of invalid credentials", {
expect_true(is(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), "NULL"))
expect_message(getAuthenticationToken(CLIENT_ID = "undefined",
CLIENT_SECRET = "undefined"), 'Token authentication unsuccessful. Check credentials and try again')
})
test_that("Authorization function returns a string", {
expect_true(is(getAuthenticationToken(), "character"))
})
library(wrappify)
library(wrappify)
library(covr)
token <- Sys.env(CODECOV_TOKEN)
token <- Sys.getenv(CODECOV_TOKEN)
library(covr)
test <- 1234
token <- Sys.getenv('CODECOV_TOKEN')
covr::codecov(token = token)
token
covr::codecov(token = "e7da888a-58fe-4b28-96ed-f41e9c667a44")
library(glue)
library(httr)
library(wrappify)
getTrackRecommendations(seed_artists = c('Ummet Ozcan', 'Robin Schulz'),
seed_genres = c('electro house', 'progressive house'),
seed_tracks = c('4l3FIRSFBFf3YQGH07FMAS'))
class(getTrackRecommendations(seed_artists = c('Ummet Ozcan', 'Robin Schulz'),
seed_genres = c('electro house', 'progressive house'),
seed_tracks = c('4l3FIRSFBFf3YQGH07FMAS')))
?anyNA
?any
anyNA(c('adawd', 'awdw', 'awdw'))
anyNA(c('adawd', 'awdw', NA))
anyNA(NA)
library(wrappify)
covr::codecov(token = Sys.getenv(CODECOV_TOKEN))
library(wrappify)
library(wrappify)
library(wrappify)
knitr::opts_chunk$set(echo = TRUE)
#setwd("~/Documents/Masters/block4/534_cloud/wrappify/wrappify")
source('R/EricsFunctions.R')
knitr::opts_chunk$set(echo = TRUE)
#setwd("~/Documents/Masters/block4/534_cloud/wrappify/wrappify")
source('R/spotify_InfoAPI.R')
setwd("~/wrappify")
setwd("wrappify")
source('R/spotify_InfoAPI.R')
usethis::use_vignette("VIGNETTE")
library(wrappify)
?isin
??isin
output <- 'dataframe'
(output %in% c("json", "dataframe", "graph"))
getAudioFeatures <- function(songId, output =  "dataframe", authentication_token = getAuthenticationToken()){
if (output %in% c("json", "dataframe", "graph") == FALSE) {
stop("output parameter must be one of json, dataframe, graph")
}
url <- glue::glue("https://api.spotify.com/v1/audio-features/{songId}")
response <- httr::GET(url, httr::add_headers(Accept = "application/json",
Authorization = paste("Bearer", authentication_token)))
content <- httr::content(response)
return(content)
if (response$status_code != 200) {
stop(paste(response$status_code,":", content$error))
}
if (output != "json") {
songname <- getSongInfo(songId, dataframe = TRUE)$trackName
df <- data.frame(metric = c("danceability", "energy", "speechiness", "acousticness",
"instrumentalness", "liveness", "valence", "tempo", "time_signature",
"duration_ms", "loudness"),
value = c(content$danceability, content$energy, content$speechiness,
content$acousticness, content$instrumentalness, content$liveness, content$valence,
content$tempo, content$time_signature, content$duration_ms, content$loudness))
if (output == "dataframe") {
return(df)
}
# Only output left is 'graph'
else {
plot <- ggplot2::ggplot(df, ggplot2::aes(y = metric, x = value)) +
ggplot2::geom_point(fill = "blue") +
ggplot2::ggtitle(paste0(songname, "'s Metrics"))+
ggplot2::ylab("Song Metric")+
ggplot2::xlab("Value") +
ggplot2::xlim(c(0,1))
return(plot)
}
} else { # User requested json
return(content)
}
}
getAudioFeatures('badrequest')
expect_error(getAudioFeatures("BADINPUT") , "400 : invalid request")
getAudioFeatures <- function(songId, output =  "dataframe", authentication_token = getAuthenticationToken()){
if (output %in% c("json", "dataframe", "graph") == FALSE) {
stop("output parameter must be one of json, dataframe, graph")
}
url <- glue::glue("https://api.spotify.com/v1/audio-features/{songId}")
response <- httr::GET(url, httr::add_headers(Accept = "application/json",
Authorization = paste("Bearer", authentication_token)))
content <- httr::content(response)
if (response$status_code != 200) {
stop(paste(response$status_code,":", content$error$message))
}
if (output != "json") {
songname <- getSongInfo(songId, dataframe = TRUE)$trackName
df <- data.frame(metric = c("danceability", "energy", "speechiness", "acousticness",
"instrumentalness", "liveness", "valence", "tempo", "time_signature",
"duration_ms", "loudness"),
value = c(content$danceability, content$energy, content$speechiness,
content$acousticness, content$instrumentalness, content$liveness, content$valence,
content$tempo, content$time_signature, content$duration_ms, content$loudness))
if (output == "dataframe") {
return(df)
}
# Only output left is 'graph'
else {
plot <- ggplot2::ggplot(df, ggplot2::aes(y = metric, x = value)) +
ggplot2::geom_point(fill = "blue") +
ggplot2::ggtitle(paste0(songname, "'s Metrics"))+
ggplot2::ylab("Song Metric")+
ggplot2::xlab("Value") +
ggplot2::xlim(c(0,1))
return(plot)
}
} else { # User requested json
return(content)
}
}
library(testthat)
expect_error(getAudioFeatures("BADINPUT") , "400 : invalid request")
library(wrappify)
library(wrappify)
library(wrappify)
?reorder
getTrackRecommendations(c('kanye west', 'chance the rapper', 'kendrick'), c('hip hop', 'rap'), '6fTdcGsjxlAD9PSkoPaLMX')
get_track_ID('sunday candy')
getTrackID('sunday candy')
getTrackID('sunday candy chance the rapper')
getTrackRecommendations(c('kanye west', 'chance the rapper', 'kendrick'), c('hip hop', 'rap'), '6fTdcGsjxlAD9PSkoPaLMX')
getTrackRecommendations(c('kanye west', 'chance the rapper', 'kendrick'), c('rap'), '6fTdcGsjxlAD9PSkoPaLMX')
getTrackRecommendations(c('kanye west', 'chance the rapper', 'kendrick'), c('rap', 'hiphop'), '6fTdcGsjxlAD9PSkoPaLMX')
getTrackRecommendations(c('kanye west', 'chance the rapper', 'kendrick'), c('rap', 'gospel'), '6fTdcGsjxlAD9PSkoPaLMX')
getTrackRecommendations(c('kanye west', 'chance the rapper', 'kendrick'), 'rap,gospel', '6fTdcGsjxlAD9PSkoPaLMX')
getTrackRecommendations(c('kanye west', 'chance the rapper', 'kendrick'), 'rap', '6fTdcGsjxlAD9PSkoPaLMX')
test_response_e_f <- getRecentEpisodes(podcast_id = '2FLQbu3SLMIrRIDM0CaiHG',
explicit = FALSE)
expect_false(any(test_response_e_f$Explicit==TRUE))
expect_false(any(test_response_e_f$Explicit==FALSE))
expect_true(any(test_response_eld_t$Explicit==TRUE))
test_response_eld_t <- getRecentEpisodes(podcast_id = '2FLQbu3SLMIrRIDM0CaiHG',
duration = 40)
expect_true(any(test_response_eld_t$Explicit==TRUE))
library(wrappify)
