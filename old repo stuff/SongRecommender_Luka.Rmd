---
title: "R Notebook"
output: html_notebook
---
###########################################################################
## To Do List:
##    - Add plot visualizations to at least 1 function
##    - Format syntax and structure
##
## luka.vuko@outlook.com - Feb 2021
###########################################################################


######################################
# 0 - Install and Load Dependencies
######################################
```{r}
install.packages("pacman")

pacman::p_load(httr, jsonlite, glue, stringr, roxygen2)
```

######################################
# 1 - Authentication Function
######################################
```{r}

get_authentication_token <- function (CLIENT_ID, CLIENT_SECRET) {
  
  
  ## Get response using user defined Client ID and Client Secret
  response = POST('https://accounts.spotify.com/api/token',
                  accept_json(),
                  authenticate(CLIENT_ID, CLIENT_SECRET),
                  body = list(grant_type = 'client_credentials'),
                  encode = 'form',
                  verbose())
  
  ## Assign a global authorization token.
  ## The user only needs to run the function to refresh their authorization token.
  auth_token <<- content(response)$access_token
  
  return(auth_token)
}

```

######################################
# 2 - Getting Token Access Requires a Client ID and Secret ID
#
# In this example these variables are stored as system variables.
# The user needs to acquire these prior to using the package.
######################################
```{r}

client_id <- Sys.getenv('Spotify_client_id')
client_secret <- Sys.getenv('Spotify_client_secret')

# Function assigns token to global that's used by each function
# Assignment follows: auth_token <<- 'XXXXX'
get_authentication_token(client_id, client_secret)

```

######################################
# 3 - Function: Artist to ID converter
######################################
```{r}

get_artist_ID <- function (artist = NA, 
                           authentication_token = auth_token) {
  
  # Check if an input was provided
  if (is.na(artist)) {
    return('No artist string provided.')
  }
  
  # Confirm input with user
  print(paste0("Searching artist: ", artist))
  
  # Format query url for the API
  artist <- str_replace_all(artist, ' ', '%20')
  url = glue('https://api.spotify.com/v1/search?q={artist}&type=artist&limit=1')
  
  # Get a response and let the user know of the response status
  response <- GET(url, add_headers(Accept = 'application/json',
                                   Authorization = paste('Bearer', authentication_token)))
  print(paste0("Search response status: ", response$status))
  
  # Parse content
  content <- content(response)$artists$items[[1]]
  
  artist_name <- content$name
  artist_id <- content$id
  artist_popularity <- content$popularity
  artist_genres <- paste(unlist(content$genres), collapse = ', ')

  # Check that an artist id was returned
  if (is.null(artist_id) | class(artist_id)=='try-error') {
    artist_id <- 'Unknown'
    print(paste0("Artist ID: ", artist_id))
    return(NULL)
  }
  
  # Prints if artist search was successful
  print(paste("Artist Found: ", artist_name))

  return(data.frame(
    'Artist.name' = c(artist_name),
    'Artist.ID' = c(artist_id), 
    'Artist.Popularity' = c(artist_popularity),
    'Genres' = c(artist_genres)))
}
```


### Testing artist to ID function:
```{r}
get_artist_ID('alt j')
```



######################################
# 4 - Function: Track to ID converter
######################################
```{r}

get_track_ID <- function(track = NA, limit = 5,
                         authentication_token = auth_token) {
  
  # Check if an input was provided
  if(is.na(track)) {
    return('No artist string provided.')
  }
  
  # Check if a token was defined
  if(is.na(auth_token)) {
    return("Authorization token not defined.
            Please run: get_authentication_token with your credentials.")
  }

  # Confirm input with user
  print(paste0("Searching track: ", track))
  
  # Format query url for the API
  track <- str_replace_all(track, ' ', '%20')
  url = glue('https://api.spotify.com/v1/search?q={track}&type=track&limit={limit}')
  
  # Get a response and let the user know of the response status
  response <- GET(url, add_headers(Accept = 'application/json', 
                                   Authorization = paste('Bearer', authentication_token)))
  print(paste0("Search response status: ", response$status))
  
  
  content <- content(response)$tracks$items
  
  # Let user know if the query returned no tracks
  if(length(content) == 0){
    print('No tracks found')
    return(NULL)
  }
  
  # Data collection frame
  tracks_found <- data.frame('Track.Name' = '',
                             'Track.Artist' = '',
                             'Track.ID' = '',
                             'Track.Popularity' = '')
  
  for (item in 1:length(content)) {
    track_name <- content[[item]]$name
    track_artists <-  content[[item]]$artists 
    track_id <- content[[item]]$id
    track_popularity <- content[[item]]$popularity
    
    # Often there are multiple artists so combine the artist names into a string
    artists <- ''
    for (artist in 1:length(track_artists)) {
      if (artist == 1) {
        artists <- glue('{track_artists[[artist]]$name}')
      } else {
        artists <- glue('{artists}, {track_artists[[artist]]$name}')
      }
    }
    
    # Except null returns by assigning them status 'Unknown'
    if (is.null(track_id) | class(track_id)=='try-error') {
      track_id <- 'Unknown'
    }
    
    # Continue appending rows to the dataframe
    tracks_found <- rbind(tracks_found, data.frame(
                          'Track.Name' = track_name,
                          'Track.Artist' = artists,
                          'Track.ID' = track_id,
                          'Track.Popularity' = track_popularity))
  }
  
  return(tracks_found)
}

```

### Testing song to ID converter
```{r}
get_track_ID('hhas')
  
```

######################################
# 5 - Function: Track Recommendation
######################################
```{r}

get_track_recommendations <- function(seed_artists, seed_genres, seed_tracks,
                                      authentication_token = auth_token,
                                      
                                      ## Optional bleow
                                      limit=10, market=NA, 
                                      min_acousticness=NA, max_acousticness=NA, target_acousticness=NA,
                                      min_danceability=NA, max_danceability=NA, target_danceability=NA,
                                      min_duration_ms=NA, max_duration_ms=NA, target_duration_ms=NA,
                                      min_energy=NA, max_energy=NA, target_energy=NA,
                                      min_instrumentalness=NA, max_instrumentalness=NA, target_instrumentalness=NA,
                                      min_key=NA, max_key=NA, target_key=NA,
                                      min_liveness=NA, max_liveness=NA, target_liveness=NA,
                                      min_loudness=NA, max_loudness=NA, target_loudness=NA,
                                      min_mode=NA, max_mode=NA, target_mode=NA,
                                      min_popularity=NA, max_popularity=NA, target_popularity=NA,
                                      min_speechiness=NA, max_speechiness=NA, target_speechiness=NA,
                                      min_tempo=NA, max_tempo=NA, target_tempo=NA,
                                      min_time_signature=NA, max_time_signature=NA, target_time_signature=NA,
                                      min_valence=NA, max_valence=NA, target_valence=NA) {
  
  # Artist names need to be converted to a string of artist IDs
  artist_ids <- ''
  for (artist in 1:length(seed_artists)) {
    if (artist == 1) {
      id <- get_artist_ID(seed_artists[artist])[2]
      artist_ids <- paste(id)
    } else {
      id <- get_artist_ID(seed_artists[artist])[2]
      artist_ids <- glue('{artist_ids}%2C{id}')
    }
  }
  
  seed_artists <- artist_ids
  
  # Genre names also need to be formatted
  genres_str <- ''
  for (genre in 1:length(seed_genres)) {
    clean <- str_replace_all(seed_genres[genre], ' ', '%20')
    if (genre == 1) {
      genres_str <- clean
    } else {
      genres_str <- glue('{genres_str}%2C{clean}')
    }
  }
  
  seed_genres <- genres_str

  base_url = 'https://api.spotify.com/v1/recommendations'
  
  # Call the query assembler to combine and remove all unspecified values from arguments
  query = query_assembler(seed_artists, seed_genres, seed_tracks, limit, market, 
                          min_acousticness, max_acousticness, target_acousticness,
                          min_danceability, max_danceability, target_danceability,
                          min_duration_ms, max_duration_ms, target_duration_ms,
                          min_energy, max_energy, target_energy,
                          min_instrumentalness, max_instrumentalness, target_instrumentalness,
                          min_key, max_key, target_key,
                          min_liveness, max_liveness, target_liveness,
                          min_loudness, max_loudness, target_loudness,
                          min_mode, max_mode, target_mode,
                          min_popularity, max_popularity, target_popularity,
                          min_speechiness, max_speechiness, target_speechiness,
                          min_tempo, max_tempo, target_tempo,
                          min_time_signature, max_time_signature, target_time_signature,
                          min_valence, max_valence, target_valence)
  

  
  # Get a response and let the user know of the response status
  url = paste0(base_url, query)
  response <- GET(url, add_headers(Accept = 'application/json',
                                   Authorization = paste('Bearer', authentication_token)))
  print(paste0("Search response status: ", response$status))

  
  # Let user know if query returned no tracks
  content <- content(response)$tracks
  if(length(content) == 0){
    print('No tracks found')
    return(NULL)
  }

  # Data collection frame
  tracks_found <- data.frame('Track.Name' = '',
                             'Track.Artist' = '',
                             'Track.ID' = '', 
                             'Track.Popularity' = '',
                             'Explicit.Status' = '',
                             'Track.Link' = '')
  
  for (item in 1:length(content)) {
    track_name <- content[[item]]$name
    artist_list <- content[[item]]$artists
    track_ID <- content[[item]]$id
    track_popularity <- content[[item]]$popularity
    track_explicit <- content[[item]]$explicit
    track_link <- content[[item]]$external_urls$spotify
    
    # Often there are multiple artists so combine the artist names into a string
    artists <- ''
    for(artist in 1:length(artist_list)){
      if(artist == 1){
        artists <- glue('{artist_list[[artist]]$name}')
      } else {
        artists <- glue('{artists}, {artist_list[[artist]]$name}')
      }
    }
    
    # Except null returns by assigning them status 'Unknown'
    if(is.null(track_ID) | class(track_ID)=='try-error') {
      track_ID <- 'Unknown'
    }
    
    # Continue appending rows to the dataframe
    tracks_found <- rbind(tracks_found,
                          data.frame(
                            'Track.Name' = track_name,
                            'Track.Artist' = artists,
                            'Track.ID' = track_ID,
                            'Track.Popularity' = track_popularity,
                            'Explicit.Status' = track_explicit,
                            'Track.Link' = track_link))
  }
  
  # Provide a data visualization metric for explicit content
  slices <- c(length(tracks_found[5][tracks_found[5] == TRUE]), length(tracks_found[5][tracks_found[5] == FALSE]))
  labs <- c(glue('Explicit ({slices[1]})'), glue('Clean ({slices[2]})'))
  pi <- pie(slices, labels = labs, main = 'Proportion of Returned Tracks\nwith Explicit Content')
  
  #
  return(list(tracks_found, pi))
}


```

######################################
# 6 - Function: Query Assembler for API Call
######################################
```{r}

query_assembler <- function(seed_artists, seed_genres, seed_tracks, limit, market, 
                            min_acousticness, max_acousticness, target_acousticness,
                            min_danceability, max_danceability, target_danceability,
                            min_duration_ms, max_duration_ms, target_duration_ms,
                            min_energy, max_energy, target_energy,
                            min_instrumentalness, max_instrumentalness, target_instrumentalness,
                            min_key, max_key, target_key,
                            min_liveness, max_liveness, target_liveness,
                            min_loudness, max_loudness, target_loudness,
                            min_mode, max_mode, target_mode,
                            min_popularity, max_popularity, target_popularity,
                            min_speechiness, max_speechiness, target_speechiness,
                            min_tempo, max_tempo, target_tempo,
                            min_time_signature, max_time_signature, target_time_signature,
                            min_valence, max_valence, target_valence) {
  
  # Capture all variables in a dataframe
  arguments <- data.frame(
                  params = c('seed_artists', 'seed_genres', 'seed_tracks', 'limit', 'market', 
                             'min_acousticness', 'max_acousticness', 'target_acousticness',
                             'min_danceability', 'max_danceability', 'target_danceability',
                             'min_duration_ms', 'max_duration_ms', 'target_duration_ms',
                             'min_energy', 'max_energy', 'target_energy',
                             'min_instrumentalness', 'max_instrumentalness', 'target_instrumentalness',
                             'min_key', 'max_key', 'target_key',
                             'min_liveness', 'max_liveness', 'target_liveness',
                             'min_loudness', 'max_loudness', 'target_loudness',
                             'min_mode', 'max_mode', 'target_mode',
                             'min_popularity', 'max_popularity', 'target_popularity',
                             'min_speechiness', 'max_speechiness', 'target_speechiness',
                             'min_tempo', 'max_tempo', 'target_tempo',
                             'min_time_signature', 'max_time_signature', 'target_time_signature',
                             'min_valence', 'max_valence', 'target_valence'),
                  vals = c(seed_artists, seed_genres, seed_tracks, limit, market, 
                              min_acousticness, max_acousticness, target_acousticness,
                              min_danceability, max_danceability, target_danceability,
                              min_duration_ms, max_duration_ms, target_duration_ms,
                              min_energy, max_energy, target_energy,
                              min_instrumentalness, max_instrumentalness, target_instrumentalness,
                              min_key, max_key, target_key,
                              min_liveness, max_liveness, target_liveness,
                              min_loudness, max_loudness, target_loudness,
                              min_mode, max_mode, target_mode,
                              min_popularity, max_popularity, target_popularity,
                              min_speechiness, max_speechiness, target_speechiness,
                              min_tempo, max_tempo, target_tempo,
                              min_time_signature, max_time_signature, target_time_signature,
                              min_valence, max_valence, target_valence))

  # Unspecified arguments need to be removed
  specified_args <- na.omit(arguments)
  
  # Format the specified arguments into Spotify call structure
  # Structure: 'var' --> 'var={var}&'
  formatted_args <- NA
  for (i in 1:nrow(specified_args)) {
    if (i==1) {
      formatted_args[[i]] <- glue('?{specified_args[i,1]}={specified_args[i,2]}')
    } else {
      formatted_args[[i]] <- glue('&{specified_args[i,1]}={specified_args[i,2]}')
    }
  }
  
  # Formatted arguments must be concatenated into a string
  assembled_query <- do.call(paste, c(as.list(formatted_args), sep = ""))
  
  return (assembled_query)
}

```



### Testing Song recommender
```{r}

## Find song IDs
#get_track_ID('sunday candy')

## Input Artist, Genre, and track ID parameters to give song recommendations
get_track_recommendations(c('kanye west', 'chance the rapper', 'kendrick'), c('hip hop'), '6fTdcGsjxlAD9PSkoPaLMX')

```

